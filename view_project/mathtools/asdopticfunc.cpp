#include <iostream>
#include "asdopticfunc.h"
#include <math.h>

/*!
 * \param Gp - угол между направлениями «объект - Солнце» и «объект - средство разведки» в град.
 * \param Sm - метеорологическая дальность видимости в км.
 * \param Ха - индикатрисы рассеяния атмосферы.
 */
float  Light (float Gpx,float Smx)
{
    float Sm[6]={1,2,4,10,20,50};
    float Gp[19]={0,10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180};
    float Xa[19][6]={{26.8,24,20.9,16.2,13.4,12.4},\
                     {17.3,16.7,15.17,12.1,9.38,8.66},
                     {7.75,8.5,8.06,6.81,5.86,5.16},
                     {3.32,4.15,4.1,3.95,4.4,3.37},
                     {1.61,2.01,2.07,2.16,2.13,2.2},
                     {0.84,1.05,1.25,1.26,1.38,1.54},
                     {0.43,0.59,0.61,0.77,0.92,1.14},
                     {0.25,0.35,0.35,0.48,0.63,0.89},
                     {0.15,0.23,0.23,0.34,0.48,0.73},
                     {0.11,0.16,0.16,0.27,0.38,0.59},
                     {0.09,0.16,0.14,0.23,0.34,0.66},
                     {0.08,0.11,0.11,0.2,0.32,0.55},
                     {0.09,0.1,0.1,0.18,0.3,0.55},
                     {0.11,0.11,0.11,0.17,0.3,0.55},
                     {0.17,0.13,0.12,0.17,0.31,0.57},
                     {0.17,0.15,0.13,0.17,0.32,0.66},
                     {0.19,0.17,0.15,0.18,0.33,0.77},
                     {0.21,0.18,0.16,0.18,0.35,0.89},
                     {0.11,0.19,0.16,0.19,0.35,1.0}};
    int ik=-1;
    float deltam=200.;
    for (int i=0;i<19;i++)
    {

       if(fabs(Gpx-Gp[i])<deltam)
       {
        deltam=fabs(Gpx-Gp[i]);
        ik=i;
       }
    }
    int jk=-1;
     deltam=60.;
    for (int j=1;j<6;j++)
    {
        if(fabs(Smx-Sm[j])<deltam)
        {
            deltam=fabs(Smx-Sm[j]);
             jk=j;
        }
    }
    float temp=Xa[ik][jk];
    return temp;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 /*!
 * \param Х1 - параметр, характеризующий вытянутость индикатрисы рассеяния.
 * \param Smx - метеорологическая дальность видимости в км.
 */
float indikat (float Smx)
{
    float Sm[6]={1,2,4,10,20,50};
    float X1[6]={2.17, 2.39, 2.20, 2.13, 1.72, 1.09};

    int ik=-1;
    float deltam=600.;
    for (int i=0;i<6;i++)
    {
       if(fabs(Smx-Sm[i])<deltam)
       {
        deltam=fabs(Smx-Sm[i]);
        ik=i;
       }
    }
    float temp1=X1[ik];
    return temp1;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /*!
     * \param LAi - длинна волны в мкм.
     * \param hq  - высота солнца в град.
     * \param A   - альбедо подстилающих поверхностей европейской части России.
     * \param FiN - широта в град.
     * \param LaN - долгота в град.
     * \param snow - для подстилающих поверхностей, покрытых снегом = 0(без размерная).
     */
float albedo (float hq, float LAi, float FiN, float LaN, float snow)
{
    float hq1[3]={10,30,45};
    float LAi1[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};
    float A1[3][8]={{0.04,0.05,0.08,0.12,0.15,0.29,0.25,0.25},///Для координат зоны 66...70/40...65
                   {0.04,0.05,0.07,0.11,0.14,0.28,0.25,0.25},
                   {0.03,0.04,0.06,0.09,0.13,0.27,0.24,0.24}};


    float hq2[3]={10,30,45};
    float LAi2[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};
    float A2[3][8]={{0.04,0.05,0.06,0.11,0.16,0.31,0.3,0.3},///Для координат зоны 64...66/30...59
                   {0.04,0.05,0.05,0.10,0.15,0.3,0.29,0.29},
                   {0.03,0.04,0.05,0.09,0.14,0.29,0.28,0.28}};
    \
    float hq3[3]={10,30,45};
    float LAi3[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};
    float A3[3][8]={{0.05,0.09,0.07,0.14,0.2,0.37,0.33,0.33},///Для координат зоны 58...64/30...57
                   {0.04,0.08,0.07,0.13,0.18,0.35,0.32,0.32},
                   {0.04,0.07,0.06,0.12,0.17,0.34,0.31,0.31}};
    float hq3_1[1]={10};                                     ///Для координат зоны 58...64/30...57
    float LAi3_1[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};       ///Данные для подстилающих слоёв, покрытых снегом.
    float A3_1[1][8]={0.5,0.51,0.48,0.45,0.42,0.38,0.35,0.35};

    float hq4[3]={10,30,45};
    float LAi4[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};
    float A4[3][8]={{0.06,0.08,0.09,0.14,0.19,0.37,0.34,0.34},///Для координат зоны 55...58/30...57
                   {0.05,0.07,0.08,0.13,0.17,0.35,0.34,0.34},
                   {0.04,0.06,0.07,0.12,0.16,0.34,0.33,0.33}};
    float hq4_1[1]={10};                                     ///Для координат зоны 55...58/30...57
    float LAi4_1[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};       ///Данные для подстилающих слоёв, покрытых снегом.
    float A4_1[1][8]={0.46,0.46,0.42,0.40,0.38,0.35,0.32,0.32};

    float hq5[3]={10,30,45};
    float LAi5[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};
    float A5[3][8]={{0.06,0.09,0.09,0.16,0.22,0.42,0.43,0.43}, ///Для координат зоны 53...60/22...30
                   {0.05,0.08,0.08,0.14,0.2,0.4,0.42,0.42},
                   {0.04,0.07,0.07,0.13,0.18,0.37,0.4,0.4}};
    float hq5_1[1]={10};                                       ///Для координат зоны 53...60/22...30
    float LAi5_1[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};         ///Данные для подстилающих слоёв, покрытых снегом.
    float A5_1[1][8]={0.52,0.53,0.49,0.47,0.44,0.4,0.36,0.36};

    float hq6[3]={10,30,45};
    float LAi6[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};
    float A6[3][8]={{0.07,0.1,0.09,0.17,0.24,0.46,0.45,0.45},  ///Для координат зоны  47...53/24...29
                   {0.06,0.08,0.08,0.15,0.22,0.43,0.43,0.43},  ///                    50...53/29...35
                   {0.05,0.07,0.07,0.14,0.2,0.4,0.41,0.41}};   ///                    53...55/30...50
    float hq6_1[1]={10};                                       ///Для координат зоны  47...53/24...29,50...53/29...35
    float LAi6_1[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};         ///                    53...55/30...50
    float A6_1[1][8]={0.58,0.6,0.56,0.53,0.5,0.45,0.4,0.4};    ///Данные для подстилающих слоёв, покрытых снегом.

    float hq7[3]={10,30,45};
    float LAi7[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};
    float A7[3][8]={{0.05,0.08,0.08,0.14,0.19,0.4,0.44,0.44},  ///Для координат зоны  51...53/35...50
                   {0.05,0.06,0.06,0.11,0.16,0.34,0.33,0.33},  ///                    53...55/50...56
                   {0.04,0.05,0.06,0.10,0.14,0.32,0.37,0.37}}; ///                    50...51/35...45
    float hq7_1[1]={10};                                       ///Для координат зоны  51...53/35...50,53...55/50...56
    float LAi7_1[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};         ///                    50...51/35...45
    float A7_1[1][8]={0.72,0.74,0.7,0.68,0.66,0.62,0.56,0.56}; ///Данные для подстилающих слоёв, покрытых снегом.

    float hq8[3]={10,30,45};
    float LAi8[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};
    float A8[3][8]={{0.06,0.08,0.1,0.16,0.21,0.43,0.45,0.45},  ///Для координат зоны  47...50/29...45
                   {0.06,0.07,0.08,0.13,0.18,0.36,0.39,0.39},  ///                    50...51/45...56
                   {0.04,0.05,0.07,0.13,0.18,0.35,0.37,0.37}}; ///                    51...53/50...56
    float hq8_1[2]={10,30};                                    ///Для координат зоны  47...50/29...45,50...51/45...56
    float LAi8_1[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};         ///                    51...53/50...56
    float A8_1[2][8]={{0.8,0.82,0.79,0.78,0.76,0.7,0.64,0.64}, ///Данные для подстилающих слоёв, покрытых снегом.
                     {0.74,0.76,0.74,0.72,0.7,0.68,0.36,0.36}};

    float hq9[3]={10,30,45};
    float LAi9[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};
    float A9[3][8]={{0.12,0.17,0.27,0.31,0.34,0.38,0.4,0.4},  ///Для координат зоны  44...50/45...55
                   {0.1,0.15,0.24,0.28,0.31,0.35,0.37,0.37},
                   {0.09,0.13,0.22,0.26,0.29,0.33,0.36,0.36}};
    float hq9_1[2]={10,30};                                    ///Для координат зоны  44...50/45...55
    float LAi9_1[8]={0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};         ///Данные для подстилающих слоёв, покрытых снегом.
    float A9_1[2][8]={{0.79,0.8,0.8,0.78,0.75,0.69,0.63,0.63},
                   {0.76,0.78,0.78,0.76,0.74,0.72,0.69,0.69}};
    float t_return=0.34;
/////////////////////Спектральные зависимости альбедо А подстилающих поверхностей европейской /////////////
////////////////////////////части России для подстилающих поверхностей, покрытых СНЕГОМ////////////////////
    if(snow==0)
    {
//////////////////////////////////_A3_1//////////////////////////////////////////////////////

     if((FiN>=58)&&(FiN<=64)&&(LaN>=30)&&(LaN<=57))
        {
            int ik=-1;
            float deltam=5.;
            for (int i=0;i<8;i++)
            {
                if(fabs(LAi-LAi3_1[i])<deltam)
                {
                    deltam=fabs(LAi-LAi3_1[i]);
                    ik=i;
                }
            }
            int jk=-1;
            deltam=20.;
            for (int j=0;j<1;j++)
            {
                if(fabs(hq-hq3_1[j])<deltam)
                {
                    deltam=fabs(hq-hq3_1[j]);
                    jk=j;
                }
            }
            t_return=A3_1[jk][ik];

        return t_return;
       }
//////////////////////////////////_A4_1//////////////////////////////////////////////////////

    if((FiN>=55)&&(FiN<=58)&&(LaN>=30)&&(LaN<=57))
       {
            int ik=-1;
            float deltam=5.;
            for (int i=0;i<8;i++)
            {
                if(fabs(LAi-LAi4_1[i])<deltam)
                {
                    deltam=fabs(LAi-LAi4_1[i]);
                    ik=i;
                }
            }
            int jk=-1;
            deltam=20.;
            for (int j=0;j<1;j++)
            {
                if(fabs(hq-hq4_1[j])<deltam)
                {
                    deltam=fabs(hq-hq4_1[j]);
                    jk=j;
                }
            }
            t_return=A4_1[jk][ik];

            return t_return;
            }
//////////////////////////////////_A5_1//////////////////////////////////////////////////////

    if((FiN>=53)&&(FiN<=60)&&(LaN>=22)&&(LaN<=30))
       {
            int ik=-1;
            float deltam=5.;
            for (int i=0;i<8;i++)
            {
                if(fabs(LAi-LAi5_1[i])<deltam)
                {
                    deltam=fabs(LAi-LAi5_1[i]);
                    ik=i;
                }
            }
            int jk=-1;
            deltam=20.;
            for (int j=0;j<1;j++)
            {
                if(fabs(hq-hq5_1[j])<deltam)
                {
                    deltam=fabs(hq-hq5_1[j]);
                    jk=j;
                }
            }
            t_return=A5_1[jk][ik];

            return t_return;
                }
//////////////////////////////////_A6_1//////////////////////////////////////////////////////
   if((FiN>=47)&&(FiN<=53)&&(LaN>=24)&&(LaN<=29)||(FiN>=50)&&(FiN<=53)&&(LaN>=29)&&(LaN<=35)||(FiN>=53)&&(FiN<=55)&&(LaN>=30)&&(LaN<=50))
   {
       int ik=-1;
       float deltam=5.;
       for (int i=0;i<8;i++)
       {
           if(fabs(LAi-LAi6_1[i])<deltam)
           {
               deltam=fabs(LAi-LAi6_1[i]);
               ik=i;
           }
       }
       int jk=-1;
       deltam=20.;
       for (int j=0;j<1;j++)
       {
           if(fabs(hq-hq6_1[j])<deltam)
           {
               deltam=fabs(hq-hq6_1[j]);
               jk=j;
           }
       }
       t_return=A6_1[jk][ik];
       return t_return;
                }
 //////////////////////////////// _A7_1//////////////////////////////////////////////////////////
   if((FiN>=51)&&(FiN<=53)&&(LaN>=35)&&(LaN<=50)||(FiN>=53)&&(FiN<=55)&&(LaN>=50)&&(LaN<=56)||(FiN>=50)&&(FiN<=51)&&(LaN>=35)&&(LaN<=45))
   {
       int ik=-1;
       float deltam=5.;
       for (int i=0;i<8;i++)
       {
           if(fabs(LAi-LAi7_1[i])<deltam)
           {
               deltam=fabs(LAi-LAi7_1[i]);
               ik=i;
           }
       }
       int jk=-1;
       deltam=20.;
       for (int j=0;j<1;j++)
       {
           if(fabs(hq-hq7_1[j])<deltam)
           {
               deltam=fabs(hq-hq7_1[j]);
               jk=j;
           }
       }
       t_return=A7_1[jk][ik];
       return t_return;
   }
//////////////////////////////// _A8_1//////////////////////////////////////////////////////////
   if((FiN>=47)&&(FiN<=50)&&(LaN>=29)&&(LaN<=45)||(FiN>=50)&&(FiN<=51)&&(LaN>=45)&&(LaN<=56)||(FiN>=51)&&(FiN<=53)&&(LaN>=50)&&(LaN<=56))
       {
           int ik=-1;
           float deltam=5.;
           for (int i=0;i<8;i++)
           {
               if(fabs(LAi-LAi8_1[i])<deltam)
               {
                   deltam=fabs(LAi-LAi8_1[i]);
                   ik=i;
               }
           }
           int jk=-1;
           deltam=40.;
           for (int j=0;j<2;j++)
           {
               if(fabs(hq-hq8_1[j])<deltam)
               {
                   deltam=fabs(hq-hq8_1[j]);
                   jk=j;
               }
           }
           t_return=A8_1[jk][ik];
           return t_return;
       }
//////////////////////////////////_A9_1///////////////////////////////////////////////////////
   if((FiN>=44)&&(FiN<=50)&&(LaN>=45)&&(LaN<=55))
   {
       int ik=-1;
       float deltam=5.;
       for (int i=0;i<8;i++)
       {
           if(fabs(LAi-LAi9_1[i])<deltam)
           {
               deltam=fabs(LAi-LAi9_1[i]);
               ik=i;
           }
       }
       int jk=-1;
       deltam=40.;
       for (int j=0;j<2;j++)
       {
           if(fabs(hq-hq9_1[j])<deltam)
           {
               deltam=fabs(hq-hq9_1[j]);
               jk=j;
           }
       }
       t_return=A9_1[jk][ik];
       return t_return;
   }

 }
///////Спектральные зависимости альбедо А подстилающих поверхностей европейской части России////////
///////////////////////////////////////////////////_A1_////////////////////////////////////////
    if((FiN>=66)&&(FiN<=70)&&(LaN>=40)&&(LaN<=65))
    {
       int ik=-1;
       float deltam=5.;
       for (int i=0;i<8;i++)
       {
       if(fabs(LAi-LAi1[i])<deltam)
         {
          deltam=fabs(LAi-LAi1[i]);
          ik=i;
         }
       }
       int jk=-1;
       deltam=50.;
       for (int j=0;j<3;j++)
       {
       if(fabs(hq-hq1[j])<deltam)
       {
       deltam=fabs(hq-hq1[j]);
       jk=j;
       }
         }
        t_return=A1[jk][ik];
       return t_return;
    }
///////////////////////////////////////////////////_A2_///////////////////////////////////////
    if((FiN>=64)&&(FiN<=66)&&(LaN>=30)&&(LaN<=59))
    {
       int ik=-1;
       float deltam=5.;
       for (int i=0;i<8;i++)
       {
       if(fabs(LAi-LAi2[i])<deltam)
         {
          deltam=fabs(LAi-LAi2[i]);
          ik=i;
         }
       }
       int jk=-1;
       deltam=50.;
       for (int j=0;j<3;j++)
       {
       if(fabs(hq-hq2[j])<deltam)
       {
       deltam=fabs(hq-hq2[j]);
       jk=j;
       }
         }
        t_return=A2[jk][ik];
       return t_return;
    }
////////////////////////////////////////////////_A3_//////////////////////////////////////////
   if((FiN>=58)&&(FiN<=64)&&(LaN>=30)&&(LaN<=57))
   {
       int ik=-1;
       float deltam=5.;
       for (int i=0;i<8;i++)
       {
           if(fabs(LAi-LAi3[i])<deltam)
           {
               deltam=fabs(LAi-LAi3[i]);
               ik=i;
           }
       }
       int jk=-1;
       deltam=50.;
       for (int j=0;j<3;j++)
       {
           if(fabs(hq-hq3[j])<deltam)
           {
               deltam=fabs(hq-hq3[j]);
               jk=j;
           }
       }
       t_return=A3[jk][ik];
       return t_return;
   }
//////////////////////////////////////////////_A4_/////////////////////////////////////////////
   if((FiN>=55)&&(FiN<=58)&&(LaN>=30)&&(LaN<=57))
   {
       int ik=-1;
       float deltam=5.;
       for (int i=0;i<8;i++)
       {
           if(fabs(LAi-LAi4[i])<deltam)
           {
               deltam=fabs(LAi-LAi4[i]);
               ik=i;
           }
       }
       int jk=-1;
       deltam=50.;
       for (int j=0;j<3;j++)
       {
           if(fabs(hq-hq4[j])<deltam)
           {
               deltam=fabs(hq-hq4[j]);
               jk=j;
           }
       }
       t_return=A4[jk][ik];
       return t_return;
   }
///////////////////////////////////////////_ A5_///////////////////////////////////////////////
if((FiN>=53)&&(FiN<=60)&&(LaN>=22)&&(LaN<=30))
{
    int ik=-1;
    float deltam=5.;
    for (int i=0;i<8;i++)
    {
        if(fabs(LAi-LAi5[i])<deltam)
        {
            deltam=fabs(LAi-LAi5[i]);
            ik=i;
        }
    }
    int jk=-1;
    deltam=50.;
    for (int j=0;j<3;j++)
    {
        if(fabs(hq-hq5[j])<deltam)
        {
            deltam=fabs(hq-hq5[j]);
            jk=j;
        }
    }
    t_return=A5[jk][ik];
    return t_return;
}
/////////////////////////////////////////_A6_////////////////////////////////////////////////
if((FiN>=47)&&(FiN<=53)&&(LaN>=24)&&(LaN<=29)||(FiN>=50)&&(FiN<=53)&&(LaN>=29)&&(LaN<=35)||(FiN>=53)&&(FiN<=55)&&(LaN>=30)&&(LaN<=50))
{
    int ik=-1;
    float deltam=5.;
    for (int i=0;i<8;i++)
    {
        if(fabs(LAi-LAi6[i])<deltam)
        {
            deltam=fabs(LAi-LAi6[i]);
            ik=i;
        }
    }
    int jk=-1;
    deltam=50.;
    for (int j=0;j<3;j++)
    {
        if(fabs(hq-hq6[j])<deltam)
        {
            deltam=fabs(hq-hq6[j]);
            jk=j;
        }
    }
    t_return=A6[jk][ik];
    return t_return;
}
///////////////////////////////////_A7_////////////////////////////////////////////////////////
if((FiN>=51)&&(FiN<=53)&&(LaN>=35)&&(LaN<=50)||(FiN>=53)&&(FiN<=55)&&(LaN>=50)&&(LaN<=56)||(FiN>=50)&&(FiN<=51)&&(LaN>=35)&&(LaN<=45))
{
    int ik=-1;
    float deltam=5.;
    for (int i=0;i<8;i++)
    {
        if(fabs(LAi-LAi7[i])<deltam)
        {
            deltam=fabs(LAi-LAi7[i]);
            ik=i;
        }
    }
    int jk=-1;
    deltam=50.;
    for (int j=0;j<3;j++)
    {
        if(fabs(hq-hq7[j])<deltam)
        {
            deltam=fabs(hq-hq7[j]);
            jk=j;
        }
    }
    t_return=A7[jk][ik];
    return t_return;
}
//////////////////////////////// _A8_//////////////////////////////////////////////////////////
if((FiN>=47)&&(FiN<=50)&&(LaN>=29)&&(LaN<=45)||(FiN>=50)&&(FiN<=51)&&(LaN>=45)&&(LaN<=56)||(FiN>=51)&&(FiN<=53)&&(LaN>=50)&&(LaN<=56))
{
    int ik=-1;
    float deltam=5.;
    for (int i=0;i<8;i++)
    {
        if(fabs(LAi-LAi8[i])<deltam)
        {
            deltam=fabs(LAi-LAi8[i]);
            ik=i;
        }
    }
    int jk=-1;
    deltam=50.;
    for (int j=0;j<3;j++)
    {
        if(fabs(hq-hq8[j])<deltam)
        {
            deltam=fabs(hq-hq8[j]);
            jk=j;
        }
    }
    t_return=A8[jk][ik];
    return t_return;
}
//////////////////////////////////_A9_///////////////////////////////////////////////////////
if((FiN>=44)&&(FiN<=50)&&(LaN>=45)&&(LaN<=55))
{
    int ik=-1;
    float deltam=5.;
    for (int i=0;i<8;i++)
    {
        if(fabs(LAi-LAi9[i])<deltam)
        {
            deltam=fabs(LAi-LAi9[i]);
            ik=i;
        }
    }
    int jk=-1;
    deltam=50.;
    for (int j=0;j<3;j++)
    {
        if(fabs(hq-hq9[j])<deltam)
        {
            deltam=fabs(hq-hq9[j]);
            jk=j;
        }
    }
    t_return=A9[jk][ik];
    return t_return;
}
 return t_return;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////Ориентировочные значения средних альбедо подстилающих поверхностей территории России/////////////////////////
/*!
 * \param Asred   - среднее альбедо подстилающих поверхностей европейской части России.
 * \param FiN     - широта безразмерная группа 1 - от 40 до 50
 * \                                    группа 2 - от 51 до 60
 * \                                    группа 3 - от 61 до 70.
 * \param month   - квартал безразмерная.
 * \param water   - для подстилающих поверхностей  на воде = 0(без размерная).
 */
float albedo_sr (float FiN,float month, float water)


{  float t_return=0.;
/////////////////////////////////Для  ВОДНЫХ поверхностей////////////////////////////////////////////////////////////////////
   if(water==0)
    {
        float month1[4]={1,2,3,4};
        float FiN1[3]={1,2,3};
        float Asred1[3][4]={{0.08,0.06,0.08,0.14},
                           {0.1,0.06,0.09,0.18},
                           {0.39,0.21,0.12,0.39}};
        {
            int ik=-1;
            float deltam=4.;
            for (int i=0;i<3;i++)
            {
                if(fabs(FiN-FiN1[i])<deltam)
                {
                    deltam=fabs(FiN-FiN1[i]);
                    ik=i;
                }
            }
            int jk=-1;
            deltam=5.;
            for (int j=0;j<4;j++)
            {
                if(fabs(month-month1[j])<deltam)
                {
                    deltam=fabs(month-month1[j]);
                    jk=j;
                }
            }
            t_return=Asred1[ik][jk];

        return t_return;
       }
}
/////////////////////////////////Для  СУШИ////////////////////////////////////////////////////////////////////

    float month2[4]={1,2,3,4};
    float FiN2[3]={1,2,3};
    float Asred2[3][4]={{0.42,0.2,0.2,0.49},
                       {0.57,0.18,0.18,0.6},
                       {0.7,0.26,0.24,0.7}};
    {
        int ik=-1;
        float deltam=4.;
        for (int i=0;i<3;i++)
        {
            if(fabs(FiN-FiN2[i])<deltam)
            {
                deltam=fabs(FiN-FiN2[i]);
                ik=i;
            }
        }
        int jk=-1;
        deltam=5.;
        for (int j=0;j<4;j++)
        {
            if(fabs(month-month2[j])<deltam)
            {
                deltam=fabs(month-month2[j]);
                jk=j;
            }
        }
        t_return=Asred2[ik][jk];

    return t_return;
   }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////Коэффициент облачности Кобл  для различных высот Солнца/////////////////////////
/*!
 * \param Kobl    - Коэффициент облачности.
 * \param hq      - высота солнца в град.
 * \param Clouds  - облачность.
 */
float Kobl (float Clouds,float hq)
{
    float hq1[12]={5,10,15,20,25,30,35,40,45,50,60,70};
    float Clouds1[8]={1,2,3,4,5,6,7,8};
    float Kobl1[8][12]={{1.25,1.22,1.13,1.09,1.19,1.23,1.25,1.19,1.18,1.13,1.06,1.05},
                        {1, 0.89, 0.87, 0.78, 0.84, 0.85, 0.85, 0.79, 0.78, 0.75, 0.71, 0.74},
                        {1.25, 1.44, 1.33, 1.3, 1.32, 1.33, 1.31, 1.28, 1.25, 1.22, 1.06, 1.11},
                        {1, 1.11, 1.07, 1, 0.97, 0.95, 0.92, 0.88, 0.85, 0.82, 0.77, 0.79},
                        {1.25, 1.22, 1.27, 1.25, 1.39, 1.38, 1.35, 1.31, 1.28, 1.26, 1.23, 1.31},
                        {1, 0.67, 0.67, 0.65, 0.65, 0.62, 0.56, 0.52, 0.48, 0.45, 0.4, 0.4},
                        {1.25, 1.11, 1.07, 1.13, 1.13, 1.13, 1.13, 1.12, 1.12, 1.12,1.12, 1.2},
                        {1, 0.67, 0.67, 0.65, 0.65, 0.62, 0.56, 0.52, 0.48, 0.45, 0.4, 0.4}
                        };
            int ik=-1;
        float deltam=80.;
        for (int i=0;i<12;i++)
        {
            if(fabs(hq-hq1[i])<deltam)
            {
                deltam=fabs(hq-hq1[i]);
                ik=i;
            }
        }
        int jk=-1;
        deltam=10.;
        for (int j=0;j<8;j++)
        {
            if(fabs(Clouds-Clouds1[j])<deltam)
            {
                deltam=fabs(Clouds-Clouds1[j]);
                jk=j;
            }
        }
    float  t_return = Kobl1[jk][ik];
    return t_return;
 }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////Специальные коэффициенты яркости материалов roi,rфi и подстилающих поверхностей (фонов)//////////////////////
////////////////////////////////////////Конструкционные материалы////////////////////////////////////////////////////////////
/*!
 * \param roi1    - Спектральный коэффициент конструкционных материалов.
 * \param roi2    - Спектральный коэффициент маскировочных материалов и комплектов.
 * \param roi3    - Спектральный коэффициент подстилающих поверхностей (фонов).
 * \param Lai     - длинна волны мкм.
 * \param matirials - материал.
 */
float roi1 (float matirials,float La)
{
    float La1[6]={0.4,0.5,0.6,0.7,0.8,0.9};
    int matirials1[31]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};
    float roix[31][6]= {{0.36,	0.34,	0.28,	0.28,	0.27,	0.27},
                        {0.85,	0.88,	0.89,	0.87,	0.85,	0.85},
                        {0.14,	0.19,	0.22,	0.24,	0.24,	0.22},
                        {0.08,	0.08,	0.08,	0.08,	0.07,	0.07},
                        {0.11,	0.12,	0.18,	0.22,	0.20,	0.20},
                        {0.51,	0.50,	0.57,	0.58,	0.61,	0.61},
                        {0.06,	0.07,	0.07,	0.08,	0.07,	0.07},
                        {0.27,	0.44,	0.72,	0.83,	0.89,	0.89},
                        {0.35,	0.61,	0.76,	0.77,	0.77,	0.75},
                        {0.18,	0.23,	0.32,	0.36,	0.36,	0.34},
                        {0.18,	0.14,	0.13,	0.08,	0.08,	0.11},
                        {0.20,	0.16,	0.15,	0.12,	0.11,	0.13},
                        {0.50,	0.61,	0.65,	0.69,	0.74,	0.74},
                        {0.52,	0.55,	0.58,	0.61,	0.62,	0.62},
                        {0.10,	0.38,	0.63,	0.70,	0.74,	0.74},
                        {0.33,	0.60,	0.72,	0.72,	0.97,	0.97},
                        {0.18,	0.30,	0.44,	0.40,	0.54,	0.54},
                        {0.11,	0.13,	0.16,	0.17,	0.19,	0.19},
                        {0.26,	0.25,	0.23,	0.20,	0.21,	0.22},
                        {0.07,	0.10,	0.15,	0.17,	0.19,	0.23},
                        {0.09,	0.12,	0.16,	0.22,	0.28,	0.28},
                        {0.07,	0.15,	0.24,	0.69,	0.75,	0.75},
                        {0.31,	0.38,	0.48,	0.48,	0.53,	0.53},
                        {0.13,	0.13,	0.13,	0.15,	0.20,	0.20},
                        {0.10,	0.12,	0.15,	0.20,	0.20,	0.20},
                        {0.10,	0.12,	0.32,	0.38,	0.38,	0.38},
                        {0.09,	0.12,	0.13,	0.13,	0.14,	0.14},
                        {0.42,	0.52,	0.58,	0.67,	0.71,	0.73},
                        {0.14,	0.20,	0.23,	0.25,	0.25,	0.25},
                        {0.17,	0.18,	0.20,	0.18,	0.17,	0.17},
                        {0.18,	0.25,	0.26,	0.35,	0.42,	0.42}
                       };
int ik=-1;
float deltam=10;
for (int i=0;i<6;i++)
{
    if(fabs(La-La1[i])<deltam)
    {deltam=fabs(La-La1[i]);
    ik=i;
    }
}
int jk=-1;
    deltam=100;
for(int j=0;j<31;j++)
{
    if(fabs(matirials-matirials1[j])<deltam)
    {deltam=fabs(matirials-matirials1[j]);
    jk=j;}
}
float t_return=roix[jk][ik];
return t_return;
}
//////////////////////////////////////////////Маскировочные материалы и комплекты/////////////////////////////////////////////////////////////////////////////////
float roi2 (float matirials,float La)
{
float La1[6]=       {0.4,0.5,0.6,0.7,0.8,0.9};
int matirials1[66]= {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66};
float roix[66][6] = {{0.07,	0.13,	0.08,	0.09,	0.10,	0.10},
                    {0.08,	0.13,	0.18,	0.18,	0.20,	0.20},
                    {0.26,	0.22,	0.07,	0.04,	0.05,	0.05},
                    {0.06,	0.08,	0.13,	0.35,	0.45,	0.45},
                    {0.12,	0.19,	0.33,	0.34,	0.34,	0.34},
                    {0.05,	0.06,	0.10,	0.12,	0.12,	0.12},
                    {0.21,	0.22,	0.21,	0.21,	0.21,	0.21},
                    {0.08,	0.07,	0.06,	0.07,	0.08,	0.08},
                    {0.09,	0.13,	0.15,	0.36,	0.69,	0.69},
                    {0.78,	0.85,	0.87,	0.88,	0.89,	0.89},
                    {0.07,	0.07,	0.10,	0.10,	0.35,	0.37},
                    {0.08,	0.08,	0.09,	0.09,	0.44,	0.44},
                    {0.03,	0.06,	0.05,   0.06,	0.38,	0.36},
                    {0.08,	0.08,	0.12,	0.11,	0.11,	0.11},
                    {0.08,	0.10,	0.14,	0.12,	0.12,	0.12},
                    {0.08,	0.09,	0.12,	0.11,	0.12,	0.12},
                    {0.08,	0.08,	0.13,	0.14,	0.12,	0.12},
                    {0.13,	0.14,	0.27,	0.27,	0.27,	0.27},
                    {0.45,	0.62,	0.64,	0.66,	0.66,	0.66},
                    {0.40,	0.45,	0.41,	0.39,	0.40,	0.43},
                    {0.06,	0.10,	0.16,	0.16,	0.21,	0.27},
                    {0.05,	0.07,	0.12,	0.13,	0.17,	0.22},
                    {0.20,	0.30,	0.39,	0.44,	0.48,	0.51},
                    {0.05,	0.16,	0.21,	0.24,	0.28,	0.33},
                    {0.44,	0.49,	0.50,	0.50,	0.46,	0.48},
                    {0.64,	0.61,	0.59,	0.58,	0.54,	0.56},
                    {0.19,	0.22,	0.22,	0.19,	0.18,	0.27},
                    {0.77,	0.84,	0.87,	0.90,	0.91,	0.91},
                    {0.86,	0.91,	0.94,	0.78,	0.79,	0.79},
                    {0.40,	0.47,	0.50,	0.51,	0.53,	0.53},
                    {0.04,	0.05,	0.10,	0.10,	0.10,	0.10},
                    {0.09,	0.15,	0.19,	0.20,	0.20,	0.20},
                    {0.06,	0.12,	0.12,	0.13,	0.14,	0.14},
                    {0.10,	0.07,	0.16,	0.17,	0.34,	0.42},
                    {0.04,	0.05,	0.05,	0.12,	0.35,	0.40},
                    {0.22,	0.25,	0.28,	0.32,	0.39,	0.43},
                    {0.16,	0.15,	0.14,	0.12,	0.14,	0.19},
                    {0.27,	0.28,	0.30,	0.33,	0.39,	0.42},
                    {0.13,	0.16,	0.15,	0.25,	0.60,	0.67},
                    {0.16,	0.17,	0.18,	0.16,	0.18,	0.23},
                    {0.49,	0.46,	0.46,	0.42,	0.39,	0.43},
                    {0.28,	0.24,	0.21,	0.20,	0.19,	0.18},
                    {0.18,	0.13,	0.12,	0.13,	0.13,	0.14},
                    {0.29,	0.39,	0.44,	0.50,	0.52,	0.54},
                    {0.25,	0.30,	0.35,	0.37,	0.39,	0.41},
                    {0.39,	0.50,	0.54,	0.52,	0.53,	0.53},
                    {0.54,	0.54,	0.53,	0.51,	0.51,	0.51},
                    {0.03,	0.05,	0.07,	0.10,	0.35,	0.35},
                    {0.04,	0.04,	0.06,	0.10,	0.42,	0.55},
                    {0.57,	0.58,	0.56,	0.56,	0.56,	0.57},
                    {0.67,	0.74,	0.73,	0.77,	0.77,	0.77},
                    {0.06,	0.07,	0.11,	0.17,	0.45,	0.50},
                    {0.07,	0.06,	0.09,	0.13,	0.20,	0.21},
                    {0.04,	0.04,	0.07,	0.12,	0.22,	0.26},
                    {0.11,	0.17,	0.22,	0.41,	0.41,	0.41},
                    {0.05,	0.05,	0.08,	0.10,	0.16,	0.17},
                    {0.04,	0.06,	0.09,	0.14,	0.27,	0.27},
                    {0.05,	0.09,	0.13,	0.15,	0.18,	0.18},
                    {0.09,	0.07,	0.07,	0.10,	0.16,	0.17},
                    {0.10,	0.15,	0.24,	0.26,	0.26,	0.26},
                    {0.09,	0.12,	0.19,	0.21,	0.23,	0.23},
                    {0.03,	0.05,	0.07,	0.12,	0.33,	0.32},
                    {0.05,	0.06,	0.07,	0.17,	0.32,	0.33},
                    {0.08,	0.09,	0.12,	0.24,	0.39,	0.37},
                    {0.55,	0.65,	0.68,	0.72,	0.76,	0.80},
                    {0.15,	0.72,	0.75,	0.75,	0.75,	0.79}
                    };
int ik=-1;
float deltam=10;
for (int i=0;i<6;i++)
{
    if(fabs(La-La1[i])<deltam)
    {deltam=fabs(La-La1[i]);
        ik=i;}
}
int jk=-1;
deltam=100;
for(int j=0;j<66;j++)
{
    if(fabs(matirials-matirials1[j])<deltam)
    {deltam=fabs(matirials-matirials1[j]);
        jk=j;}
}
float t_return=roix[jk][ik];
return t_return;

}
//////////////////////////////////////////////Подстилающие поверхности (фоны)/////////////////////////////////////////////////////////////////////////////////
float roi3 (float matirials,float La)
{
float La1[6]=       {0.4,0.5,0.6,0.7,0.8,0.9};
int matirials1[90]= {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90};
float roix[90][6] = {{0.71,	0.74,	0.75,	0.78,	0.78,	0.78},
                     {0.85,	0.90,	0.90,	0.90,	0.89,	0.89},
                     {0.83,	0.87,	0.87,	0.86,	0.86,	0.86},
                     {0.62,	0.67,	0.69,	0.67,	0.62,	0.62},
                     {0.26,	0.39,	0.48,	0.50,	0.50,	0.47},
                     {0.52,	0.61,	0.64,	0.69,	0.71,	0.67},
                     {0.09,	0.14,	0.16,	0.20,	0.23,	0.23},
                     {0.02,	0.03,	0.03,	0.04,	0.05,	0.05},
                     {0.10,	0.16,	0.23,	0.27,	0.34,	0.34},
                     {0.05,	0.06,	0.08,	0.08,	0.09,	0.09},
                     {0.02,	0.03,	0.03,	0.04,	0.06,	0.06},
                     {0.10,	0.12,	0.17,	0.21,	0.24,	0.30},
                     {0.02,	0.03,	0.04,	0.06,	0.08,	0.09},
                     {0.02,	0.02,	0.02,	0.02,	0.02,	0.02},
                     {0.04,	0.10,	0.20,	0.15,	0.24,	0.24},
                     {0.07,	0.09,	0.11,	0.13,	0.20,	0.22},
                     {0.10,	0.12,	0.16,	0.20,	0.30,	0.30},
                     {0.05,	0.09,	0.10,	0.22,	0.35,	0.36},
                     {0.07,	0.08,	0.09,	0.11,	0.12,	0.12},
                     {0.05,	0.05,	0.06,	0.08,	0.11,	0.11},
                     {0.10,	0.16,	0.23,	0.29,	0.32,	0.33},
                     {0.10,	0.20,	0.30,	0.36,	0.39,	0.41},
                     {0.30,	0.34,	0.40,	0.46,	0.49,	0.49},
                     {0.19,	0.19,	0.30,	0.35,	0.40,	0.41},
                     {0.52,	0.52,	0.56,	0.55,	0.54,	0.54},
                     {0.42,	0.46,	0.49,	0.50,	0.49,	0.49},
                     {0.32,	0.37,	0.43,	0.41,	0.40,	0.40},
                     {0.23,	0.33,	0.48,	0.53,	0.53,	0.53},
                     {0.38,	0.55,	0.65,	0.72,	0.75,	0.75},
                     {0.17,	0.22,	0.23,	0.23,	0.35,	0.35},
                     {0.06,	0.07,	0.08,	0.06,	0.07,	0.07},
                     {0.36,	0.61,	0.70,	0.78,	0.75,	0.75},
                     {0.03,	0.05,	0.10,	0.19,	0.50,	0.50},
                     {0.04,	0.08,	0.11,	0.25,	0.62,	0.62},
                     {0.04,	0.06,	0.10,	0.20,	0.50,	0.50},
                     {0.05,	0.07,	0.10,	0.18,	0.27,	0.27},
                     {0.04,	0.06,	0.07,	0.16,	0.30,	0.30},
                     {0.04,	0.06,	0.11,	0.27,	0.30,	0.30},
                     {0.04,	0.03,	0.06,	0.10,	0.31,	0.31},
                     {0.03,	0.04,	0.07,	0.15,	0.20,	0.20},
                     {0.52,	0.52,	0.47,	0.45,	0.51,	0.52},
                     {0.07,	0.13,	0.16,	0.40,	0.71,	0.71},
                     {0.04,	0.05,	0.08,	0.10,	0.29,	0.29},
                     {0.02,	0.03,	0.05,	0.14,	0.25,	0.25},
                     {0.05,	0.08,	0.11,	0.11,	0.24,	0.24},
                     {0.05,	0.03,	0.07,	0.10,	0.25,	0.25},
                     {0.06,	0.08,	0.13,	0.18,	0.28,	0.28},
                     {0.04,	0.05,	0.07,	0.10,	0.17,	0.17},
                     {0.04,	0.05,	0.05,	0.10,	0.42,	0.44},
                     {0.02,	0.04,	0.07,	0.08,	0.40,	0.42},
                     {0.06,	0.11,	0.20,	0.30,	0.38,	0.38},
                     {0.05,	0.13,	0.12,	0.15,	0.33,	0.33},
                     {0.03,	0.05,	0.08,	0.15,	0.35,	0.35},
                     {0.08,	0.07,	0.05,	0.06,	0.12,	0.12},
                     {0.16,	0.12,	0.11,	0.20,	0.24,	0.24},
                     {0.23,	0.23,	0.23,	0.28,	0.27,	0.26},
                     {0.38,	0.37,	0.35,	0.37,	0.36,	0.42},
                     {0.07,	0.08,	0.07,	0.10,	0.13,	0.12},
                     {0.04,	0.05,	0.08,	0.12,	0.48,	0.48},
                     {0.05,	0.06,	0.07,	0.10,	0.10,	0.10},
                     {0.06,	0.10,	0.20,	0.34,	0.58,	0.58},
                     {0.04,	0.03,	0.04,	0.08,	0.21,	0.21},
                     {0.04,	0.06,	0.16,	0.16,	0.27,	0.27},
                     {0.07,	0.07,	0.08,	0.15,	0.13,	0.13},
                     {0.34,	0.38,	0.43,	0.45,	0.54,	0.57},
                     {0.14,	0.13,	0.13,	0.14,	0.28,	0.30},
                     {0.08,	0.06,	0.04,	0.07,	0.12,	0.12},
                     {0.04,	0.07,	0.08,	0.20,	0.57,	0.64},
                     {0.05,	0.12,	0.36,	0.37,	0.62,	0.72},
                     {0.03,	0.06,	0.07,	0.09,	0.10,	0.10},
                     {0.12,	0.16,	0.22,	0.30,	0.30,	0.30},
                     {0.06,	0.07,	0.09,	0.11,	0.13,	0.13},
                     {0.04,	0.08,	0.12,	0.15,	0.22,	0.22},
                     {0.03,	0.07,	0.09,	0.12,	0.19,	0.19},
                     {0.03,	0.04,	0.07,	0.10,	0.11,	0.11},
                     {0.50,	0.48,	0.42,	0.39,	0.36,	0.34},
                     {0.84,	0.83,	0.80,	0.80,	0.72,	0.67},
                     {0.10,	0.12,	0.15,	0.16,	0.22,	0.22},
                     {0.02,	0.05,	0.06,	0.11,	0.18,	0.18},
                     {0.41,	0.37,	0.40,	0.38,	0.36,	0.36},
                     {0.11,	0.16,	0.23,	0.32,	0.35,	0.35},
                     {0.05,	0.06,	0.07,	0.07,	0.07,	0.07},
                     {0.26,	0.30,	0.37,	0.40,	0.40,	0.40},
                     {0.13,	0.14,	0.15,	0.16,	0.16,	0.17},
                     {0.28,	0.30,	0.36,	0.39,	0.39,	0.39},
                     {0.11,	0.12,	0.15,	0.17,	0.18,	0.18},
                     {0.15,	0.09,	0.05,	0.03,	0.02,	0.02},
                     {0.15,	0.19,	0.20,	0.15,	0.09,	0.09},
                     {0.07,	0.07,	0.02,	0.02,	0.02,	0.02},
                     {0.02,	0.03,	0.04,	0.03,	0.03,	0.03},
                     };
int ik=-1;
float deltam=100;
for (int i=0;i<6;i++)
{
    if(fabs(La-La1[i])<deltam)
    {deltam=fabs(La-La1[i]);
        ik=i;}
}
int jk=-1;
deltam=1000;
for(int j=0;j<90;j++)
{
    if(fabs(matirials-matirials1[j])<deltam)
    {deltam=fabs(matirials-matirials1[j]);
        jk=j;}
}
float t_return=roix[jk][ik];
return t_return;
}
// func fitenson


double  calcAreaObj(double l1, double l2,
                                double h, double betta_m)
{

    //! перевод в радианы
    betta_m *= DEG_TO_RAD;

    double S0 = 0.;

    double tmp = pow( (pow(l1,2) + pow(l2,2)), 0.5);

    S0 =  tmp * (h*cos(betta_m) + l1*l2*sin(betta_m)/tmp);


    return S0;
}

double  calcPerimetrObj(double l1, double l2,
                                    double h, double betta_m)
{
    betta_m *= DEG_TO_RAD;

    double G0=0.;

    double tmp1 = l1 * pow( (pow(l1,2) + pow(l2,2)*pow(sin(betta_m),2)) , 0.5);
    double tmp2 = l2 * pow( (pow(l2,2) + pow(l1,2)*pow(sin(betta_m),2)) , 0.5);

    G0 = 2 * (h * cos(betta_m)+ (tmp1 +tmp2)/pow( (pow(l1,2) + pow(l2,2)), 0.5));


    return G0;
}

double  calcRadiusOpOkr(double l1, double l2,
                                    double h, double betta_m)
{
    double Ropo;

    betta_m *= DEG_TO_RAD;

    Ropo = 0.5 * pow((pow(l1,2) + pow(l2,2) + pow(h,2)*cos(betta_m)),0.5);


    return Ropo;

}

double  calcRadiusVpisOkr_1(double l1, double l2,
                                        double h, double betta_m)
{
    double Rvpo_1;

    betta_m *= DEG_TO_RAD;

    double tmp1 = h * cos(betta_m) + l2*pow(pow(l1,2)+pow(l2,2),0.5)*sin(betta_m)/l1;
    double tmp2 = pow(1+pow(l2/l1,2), 0.5) * sin(betta_m);

    Rvpo_1 = 0.5*tmp1/tmp2;


    return Rvpo_1;

}

double  calcRadiusVpisOkr_2(double l1, double l2)
{
    double Rvpo_2 = 0.5 * pow( pow(l1,2) + pow(l2,2), 0.5);


    return Rvpo_2;

}

double  calcAreaShadow(double l1, double l2,
                                   double h, double hq, double betta_m)
{
    double S_shadow;

    hq *= DEG_TO_RAD;
    betta_m *= DEG_TO_RAD;

    S_shadow = pow( pow(l1,2)+pow(l2,2) , 0.5) * h * cos(hq) * sin(betta_m) / sin(hq);


    return S_shadow;

}

double  calcPerimetrShadow(double l1, double l2,
                                       double h, double hq, double betta_m)
{
    double G_shadow;
    hq *= DEG_TO_RAD;
    betta_m *= DEG_TO_RAD;

    double tmp1 = l1 * pow( (pow(l1,2) + pow(l2,2)*pow(sin(betta_m),2)) , 0.5);
    double tmp2 = l2 * pow( (pow(l2,2) + pow(l1,2)*pow(sin(betta_m),2)) , 0.5);

    G_shadow = 2 * (h * cos(hq) * sin(betta_m) / sin(hq)+ (tmp1 +tmp2)/pow( (pow(l1,2) + pow(l2,2)), 0.5));


    return G_shadow;

}

double  calcRadiusOpOkrShadow(double l1, double l2,
                                          double h, double hq, double betta_m)
{
    double Ropsh;

    hq *= DEG_TO_RAD;
    betta_m *= DEG_TO_RAD;

    Ropsh = 0.5 * pow((pow(l1,2) + pow(l2,2) + pow(h*cos(hq)*sin(betta_m)/sin(hq),2)),0.5);

    return Ropsh;

}

double  calcRadiusVpisOkrShadow_1(double l1, double l2,
                                              double h, double hq, double betta_m)
{
    double RvpoSh_1;

    betta_m *= DEG_TO_RAD;
    hq *= DEG_TO_RAD;

    double tmp1 = h *cos(hq)* sin(betta_m)/sin(hq);
    double tmp2 = pow(1+pow(l1*sin(betta_m)/l2,2), 0.5);

    RvpoSh_1 = 0.5*tmp1/tmp2;


    return RvpoSh_1;


}

double  calcRadiusVpisOkrShadow_2(double l1, double l2)
{
    double RvpoSh_2 = 0.5 * pow( pow(l1,2) + pow(l2,2) ,0.5);

    return RvpoSh_2;

}

QVector <double>  calcPokazatel(QVector<double> lambda, double a0)
{
    QVector <double> a;
    int k = lambda.size();
    if(k==0)return a;

    for(int i = 0 ; i < k ; i++)
        a.push_back(a0*pow(0.55/lambda[i],4.0));

    return a;

}

QVector<double>  calcOPT_tol_ATM_Mol(QVector<double> a,double Dh,
                                                 double hmin, double hmax, double alfa)
{
    QVector<double> Km;

    int k = a.size();
    if(k==0)return Km;

    double tmp1 = -1*alfa*hmin;
    double tmp2 = -1*alfa*(hmax-hmin);


    if(hmin!=hmax)
        for(int i = 0; i<k ; i++)
            Km.push_back( -a[i]*exp(tmp1) * Dh*(1.-exp(tmp2))/ tmp2);
    else
        for(int i = 0; i<k ; i++)
            Km.push_back( a[i]*exp(tmp1)*Dh);



    return Km;
}

QVector<double>  calcPOK_Aero_Ras(QVector<double> lambda, double Sm)
{
    QVector<double> b;

    int k = lambda.size();
    if(k==0)return b;

    double tmp = 0.585*pow(Sm,0.33333333);

    for(int i = 0 ; i<k; i++)
        b.push_back(3.91*pow((0.55/lambda[i]),tmp)/Sm);



    return b;
}

QVector<double>  calcOPT_tol_ATM_Aero(QVector<double> b, double Dh,double hmin,
                                                  double hmax, double Sm,double omega_N)
{
    QVector<double> Ka;
    int k = b.size();
    if(k==0)return Ka;

    ///коэффициент затухания,(1/км), слоя атмосферы на высотах от 0 до 5 км
    double beta = 0.2 * (6.658 - log(Sm));
    double beta1 = 0.1;//коэффициент затухания атмосферы на высотах свыше 5 км (1/км)

    QVector <double> b1; //показатель аэрозольного рассеяния,(1/км), на высоте 5 км

    for(int i = 0; i<k; i++)
        b1.push_back(b[i]*exp(-5.0*beta));

    if(hmax<=5){
        double tmp1 = exp(-1 * beta * hmin) * Dh / (beta*(hmax-hmin));
        double tmp2 = 1. - exp(-1. * beta * (hmin-hmax));
        tmp1 *= tmp2;

        tmp2 = exp(-1 * beta * hmax) * Dh;

        if(hmin!=hmax)
            for(int i = 0; i<k ; i++)
                Ka.push_back( b[i] * tmp1);
        else
            for(int i = 0; i<k ; i++)
                Ka.push_back(b[i]*tmp2);



        return Ka;

    }
    if(hmin>=5){



        double tmp1 = exp(-1 * beta1*(hmin - 5.)) * Dh * (1. - exp(-1*beta1*(hmax-hmin))) /
                (beta1*(hmax-hmin));
        double tmp2 = exp(-1. * beta1*(hmin-5.))*Dh;


        if(hmin!=hmax)
            for(int i = 0; i<k ; i++)
                Ka.push_back( b1[i] * tmp1);
        else
            for(int i = 0; i<k ; i++)
                Ka.push_back(b[i]*tmp2);


        return Ka;
    }
    if(hmin<5 && hmax>5){

        omega_N *=DEG_TO_RAD;

        ///угол между линией визирования средства разведки и направлением "центр Земли - точка
        ///пересечения линией визирования слоя атмосферы на высоте 5 км"
        double ksi =0;
        double tttz=(R_EARTH+hmax)*sin(omega_N)/(R_EARTH+5.);
      if(tttz<=1) ksi=asin(tttz);




        if(ksi<= 90*DEG_TO_RAD)
            ksi = M_PI - ksi;


        //геоцентрический угол между направлением на средство разведки и
        //направлением на точку пересечения линией визирования слоя атмосферы на высоте 5 км
        double Teta2 = M_PI - omega_N - ksi;
if(Teta2<0) Teta2=0.;
        //D2 - длина трассы (км) распространения излучения в слое атмосферы на высотах свыше 5 км
        double D2 = pow( pow(R_EARTH+hmax,2.)+ pow(R_EARTH+5.,2.)
                         - 2.*(R_EARTH+hmax)*(R_EARTH+5.)*cos(Teta2)     ,0.5);


        //D1 - длина трассы (км) распространения излучения в слое атмосферы на высотах от 0 до 5 км
        double D1 =Dh - D2;
//new 20.05.2016 ort
        D1=5./cos(omega_N);
        D2=Dh - D1;

        ///end new

        double tmp1 = exp(- beta*hmin)*D1*(1-exp(-beta*(5.-hmin)))/(beta*(5.-hmin));
        double tmp2 = D2*(1.-exp(-beta1*(hmax-5.)))/(beta1*(hmax-5.));

        for(int i = 0; i<k ; i++)
            Ka.push_back(b[i]*tmp1+b1[i]*tmp2);


    }


    return Ka;
}

QVector<double>  calcOPT_tol(QVector<double> Ka, QVector<double> Km)
{
    QVector<double> K;

    int k = Ka.size();
    if(k==0)return K;

    for(int i = 0; i<k; i++)
        K.push_back(Ka[i]+Km[i]);


    return K;
}

QVector<double>  calcKoef_propusk(QVector<double> K)
{
    QVector<double> tau;

    int k = K.size();
    if(k==0)return tau;

    for(int i = 0; i < k; i++)
        tau.push_back(exp(-K[i]));

    return tau;
}

QVector<double>  calcOPT_tol_mol(QVector<double> a, double alfa)
{
    QVector<double> Kmo;
    int k = a.size();
    if(k==0)return Kmo;

    for(int i=0;i<k;i++)
        Kmo.push_back(a[i]/alfa);


    return Kmo;
}

QVector<double>  calcOPT_tol_aero(QVector<double> b, double Sm)
{
    ///коэффициент затухания,(1/км), слоя атмосферы на высотах от 0 до 5 км
    double beta = 0.2 * (6.658 - log(Sm));

    QVector<double> Kao;
    int k = b.size();
    if(k==0)return Kao;

    for(int i=0;i<k;i++)
        Kao.push_back(b[i]*(1. + (10.*beta - 1) * exp(-5.*beta))/beta);

    return Kao;

}

QVector<double>  calcOPT_tol_all(QVector<double> kao, QVector<double> kmo)
{
    QVector<double> All_k;
    int k = kao.size();
    if(k==0)return All_k;

    for(int i=0;i<k;i++)
        All_k.push_back(kao[i]+kmo[i]);

    return All_k;

}

QVector<double>  calcIndikatris(QVector<double> kao, QVector<double> kmo,
                                            QVector<double> ko, double Xa, double gamma_p)
{
    gamma_p *=DEG_TO_RAD;
    QVector<double> indikatrisa;
    int k = kao.size();
    if(k==0)return indikatrisa;

    for(int i=0;i<k;i++)
        indikatrisa.push_back((0.75*kmo[i]*(1.+pow(cos(gamma_p),2.))+kao[i]*Xa)/ko[i]);


    return indikatrisa;

}

QVector<double>  calcKoef_Propusk_Atm(QVector<double> ko, double hq)
{

    hq *=DEG_TO_RAD;
    QVector<double> tau_q;
    int k = ko.size();
    if(k==0)return tau_q;
    for(int i=0;i<k;i++)
        tau_q.push_back(exp(-ko[i]/sin(hq)));

    return tau_q;
}

QVector<double>  calcKoef_P(QVector<double> tau_q, double hq)
{
    hq *=DEG_TO_RAD;
    QVector<double> P;
    int k = tau_q.size();
    if(k==0)return P;
    for(int i=0;i<k;i++)
        P.push_back(1 + 1.5*sin(hq) + tau_q[i] * (1. - 1.5 * sin(hq)));

    return P;
}

QVector<double>  calcKoef_Q(QVector<double> albedo, QVector<double> P,
                                        QVector<double> ko, double x1, double hq)
{
    hq *=DEG_TO_RAD;
    QVector<double> Q;
    int k = albedo.size();
    if(k==0)return Q;
    for(int i=0;i<k;i++)
        Q.push_back((1-albedo[i])*P[i]*sin(hq)/(8+2.*ko[i]*(1.-albedo[i])*(3.-x1)));

    return Q;
}

QVector<double>  calcKoef_C(QVector<double> Q, double hq)
{
    hq *=DEG_TO_RAD;
    QVector<double> C;
    int k = Q.size();
    if(k==0)return C;
    for(int i=0;i<k;i++)
        C.push_back(0.5*(1 + 1.5*sin(hq))*sin(hq)-2.*Q[i]);

    return C;
}

QVector<double>  calcParam_L1(QVector<double> tau, QVector<double> tau_q,
                                          double hq, double omega_N)
{
    hq *=DEG_TO_RAD;
    QVector<double> L1;
    int k = tau.size();
    if(k==0)return L1;
    for(int i=0;i<k;i++)
        L1.push_back((1.-tau[i]*tau_q[i])*sin(hq)/(4.*(sin(hq)+cos(omega_N))));

    return L1;
}

QVector<double>  calcParam_L2(QVector<double> tau, QVector<double> C, QVector<double> Q,
                                          QVector<double> ko, QVector<double> L1,
                                          double hq, double omega_N, double x1)
{
    hq *=DEG_TO_RAD;
    QVector<double> L2;
    int k = tau.size();
    if(k==0)return L2;
    for(int i=0;i<k;i++)
        L2.push_back(C[i] - 3.*Q[i]*cos(omega_N)*(1-tau[i]) + (3.-x1)*Q[i]*ko[i]*tau[i] +
                     (x1*cos(omega_N)*sin(hq)-3.*pow(sin(hq),2.))*L1[i]);

    return L2;
}

QVector<double>  calcParam_L(QVector<double> L1, QVector<double> L2,
                                         QVector<double> indikatrisa)
{
    QVector<double> L;
    int k = L1.size();
    if(k==0)return L;
    for(int i=0;i<k;i++)
        L.push_back(indikatrisa[i]*L1[i]+L2[i]);

    return L;
}

QVector<double>  calcZadim(QVector<double> albedo, QVector<double> Q,
                                       QVector<double> L, QVector<double> tau,
                                       double K_obl, double hmax)
{
    QVector<double> PSI;
    int k = albedo.size();
    if(k==0)return PSI;

    QVector<double> PSI0;

    for(int i=0;i<k;i++)
    {
        double z=(4.*Q[i]*tau[i]*K_obl);
        if(fabs(z)>0)
        {
        PSI0.push_back((1.-albedo[i])*L[i]/(4.*Q[i]*tau[i]*K_obl));
        }
        else
            PSI0.push_back(1.);
    }
    for(int i=0;i<k;i++)
        PSI.push_back(PSI0[i]*(1-exp(-0.13*hmax)));
       // PSI0[i]*=1.-exp(-0.13*hmax);

    return PSI;
}

QVector<double>  calcSpectr_plot(QVector<double> albedo, QVector<double> lambda,
                                             QVector<double> P, QVector<double> ko, QVector<double> tau_q,
                                             double K_obl, double x1, double hq)
{
    hq *=DEG_TO_RAD;
    QVector<double> E,Ep;
    int k = albedo.size();
    if(k==0)return Ep;

    QVector<double> E0;

    for(int i=0;i<k;i++)
        E0.push_back(7.1*pow(10.,3.)*pow(lambda[i],-5.)/(exp(2.37/lambda[i])-1.));
    for(int i=0;i<k;i++)
    {
        double z=(4.+ko[i]*(3.-x1)*(1.-albedo[i]));
        if(fabs(z)>0)
        {
         E.push_back(E0[i]*2.*P[i]*sin(hq)*K_obl/z);
        }
        else
             E.push_back(E0[i]*2.*P[i]*sin(hq)*K_obl);

    }

       // for(int i=0;i<k;i++)
       //Ep.push_back(E[i]-E0[i]*tau_q[i]*sin(hq));

    return E;


}






